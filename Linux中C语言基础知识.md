## C语言基础点

- float比较
- 预处理#errror
- L,U,F
> U:unsigned
> L:long/double
> F:float
- #ASSERT
- strcpy和memcpy的区别
- 指针相关
> 一个有10个指针的数组，该指针是指向一个整型数的	int *p[10]
> 一个指向有10个整型数数组的指针	int (*p)[10]
> 一个指向函数的指针，该函数有一个整型参数并返整型数	int (*p)(int)
> 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数	int (*p[10])(int)
- 字符串常量
> char *s = "AAA";const char *ss = "BBB";
- C和C++中struct有什么不同？
> C和C++中的struct主要区别是C中的struct不可以含有成员函数，而C++中的struct可以。C++中struct和class的主要区别在于默认的存取权限不同,struct默认为public,而class默认为private
- #define和const的区别
> #define是预处理指令，在编译期间被替换。const是有类型的，编译期间会进行检查，更安全。用const修饰方便调试，#define不容易调试。#define用法更加灵活一点。
- 引用和指针的区别
> 引用在创建时必须被初始化，指针可以在任何时候初始化。
> 引用不能引用NULL，指针可以
> 引用被初始化了以后就不能再去引用别的了，指针被初始化了以后还能再去指向别的
- 野指针和悬空指针
> “悬空指针”是指向被释放内存的指针，“野指针”则是不确定其具体指向的指针。
- 数组和链表的区别
> 数组在逻辑存储上和物理存储上相连，链表在逻辑存储上相连，物理存储上不一定相连。
> 数组容易查找不容易增加删除，链表容易在开头结尾出增加删除。
> 数组需要一次性把空间分配好，链表可以动态的增加存储空间
- 大端小端判断
> 联合体
> 强制类型转换
- 字符串是以0结束的
```C
char aa[10];
//gcc不会对aa进行清零操作，（不是所有的编译器会）,
//字符串是以0结束，strlen(aa)会是一个不可预期的值
printf("%d\n",strlen(aa));
```
- 位域
```C
struct A
{
	char t:4;
	char k:4;
	unsigned short i:8;
	unsigned long m;
};
```
- C语言的函数参数中没有引用，C++中有，C++用引用做函数参数的时候效果和指针差不多
- C89中是没有bool的，C99中才有bool
- int a,b,c写一个函数实现c=a+b。（注意要考虑溢出）
```C
bool add(int a,int b, int *c)
{
	*c = a + b;
	return ((a>0)&&(b>0)&&(*c<a||*c<b)||(a<0)&&(b<0)&&(*c>a||*c>b));
}
```
- 谈谈select和epoll
> select:遍历的fd在linux上有数量限制,1024个
> select:对fd的扫描形式是一种遍历的方式,要找到发生的事件必须从头开始扫,
对没有发生事件的fd做了大量无用功.
> select:fd从用户态拷贝到内核态,每次都需要复制,产生巨大的开销
> epoll:没有最大的fd限制,只受到服务端内存大小的限制
> epoll:效率提升,只有句柄中有事件发生,就会调用回调函数,把相应的fd放到就绪链接表中,
不用从头开始遍历fd
> epoll:当fd数量较少时,epoll的速度不见得比select的速度快
- 结构体变量如何比较？
> 虽然结构体变量之间可以通过=直接赋值，但不同通过比较符如==来比较，因为比较符只作用于基本数据类型。这个时候，只能通过int memcmp(const void *s1, const void *s2, size_t n);来进行内存上的比较。
## 单片机基础知识点

- 单片机的最小系统？内部的主要结构？
> 最小系统：电源、晶振（为系统提供基本的时钟信号）、复位电路；内部结构：ROM/RAM、计时器、中断、I/O串并行口、总线扩展控制。
- RAM和ROM的区别？
> ROM（只读存储器，类似硬盘）：它的信息一次写入后只能被读出，而不能被操作者修改或者删除。一般用于存放固定的程序或数据表格。但是，“只读”这个概念有时候可以被一些新特性的器件颠覆。
> RAM（随机存储器，类似内存）：它就是我们平时说的内存，主要用来存放各种现场的输入/输出数据、中间计算结果，以及与外部存储器交换信息，或者作堆栈（特点：先进后出，后进先出）用。它的存储单元根据具体需要可以读出或者改写。
> 两者区别：RAM只能用于暂时存放程序与数据。一旦电源关闭或发生断电，RAM中的数据就会丢失。而ROM中的数据在电源关闭或者断电后仍然会保留下来。
- 单片机I/O口有什么作用？
> I/O口最主要的功能用来与外部器件实现数据信息的交互、速度匹配、数据传送方式和增强单片机的负载能力
- 什么是时钟电路？
> 时钟电路就是产生像时钟一样准确运动的振荡电路，任何工作都按时间顺序。用于产生这个时间的电路就是时钟电路。组成：晶体振荡器、晶震控制芯片和电容组成。
- 单片机的寻址方式有哪些？
> 1、立即寻址，寻址空间为ROM；
> 2、直接寻址，寻址空间为片内RAM的低128B和特殊功能寄存器；
> 3、寄存器寻址，寻址空间为A、B、DPTR、CY、通用工作寄存器等；
> 4、寄存器间接寻址，片内RAM低128B、片外RAM；
> 5、相对寻址，寻址空间为ROM；
> 6、变址寻址，寻址空间为ROM；
> 7、位寻址，寻址空间为片内RAM低128B的位寻址区的128个位，其字节地址为20H~2FH；以及部分可以位寻址的特殊功能寄存器。
- 什么是时钟周期？机器周期？指令周期？它们之间的关系？
> 时钟周期是最小单位，机器周期需要1个或者多个时钟周期，指令周期需要1个或者多个机器周期；机器周期是指完成一个基本操作的时间。指令周期是CPU的关键指标，指取出并执行一条指令的时间。一般以机器周期为单位，分单指令执行周期、双指令执行周期等。机器周期是完成一个基本操作的时间单元。时钟周期是CPU的晶振的工作频率的倒数。
- 看门狗的原理?
> 工作原理：在系统运行以后就启动看门狗计数器，此时看门狗就开始自动计时，如果达到一定的时间还不去给它进行清零，看门狗计数器就会溢出从而引起看门狗中断，造成系统的复位。
- 看门狗分为软件看门狗和硬件看门狗,在什么情况下软件看门狗失效?
> 硬件看门狗是利用一个定时器电路，其定时输出连接到电路的复位端，程序在一定时间范围内对定时器清零，因此程序正常工作时，定时器总不能溢出，也就不能产生复位信号。如果程序出现故障，不在定时周期内复位看门狗，就使得看门狗定时器溢出产生复位信号并重启系统。
> 软件看门狗原理上一样，只是将硬件电路上的定时器用处理器的内部定时器代替，这样可以简化硬件电路设计，但是在可靠性方面不如硬件定时器。
- 复位时单片机有什么动作?
> 主要做的就是初始化每个寄存器，包括最重要的PC指针，不包括RAM，然后单片机从复位地址开始执行程序。
- 单片机常见复位源?
> 上电复位、软件复位、看门狗复位...(还有其它的)
- 中断嵌套的优缺点
> 当高优先级的中断发生时，允许打断低优先级的中断
> 如果高优先级的中断占用较长时间，那么低优先级的中断需要延后很久。
- 中断在单片机中起到什么作用?
> 中断能实现快速的CPU与慢速的外设同步工作，实现数据传送、故障检测与处理、人机联系、多机系统、多道程序分时操作、实时信息处理等。

- 中断处理程序和任务都会访问的临界段代码，需要使用关中断的方法加以保护；仅由任务访问的临界段代码，可以通过给调度器上锁的方法来保护。

## linux驱动开发面试题

- Linux设备中字符设备与块设备有什么主要的区别？请分别列举一些实际的设备说出它们是属于哪一类设备。
> 字符设备：字符设备是个能够像字节流（类似文件）一样被访问的设备，由字符设备驱动程序来实现这种特性。字符设备驱动程序通常至少实现open,close,read和write系统调用。字符终端、串口、鼠标、键盘、摄像头、声卡和显卡等就是典型的字符设备。
> 块设备：和字符设备类似，块设备也是通过/dev目录下的文件系统节点来访问。块设备上能够容纳文件系统，如：u盘，SD卡，磁盘等。
> 字符设备和块设备的区别仅仅在于内核内部管理数据的方式，也就是内核及驱动程序之间的软件接口，而这些不同对用户来讲是透明的。在内核中，和字符驱动程序相比，块驱动程序具有完全不同的接口。

- 查看驱动模块中打印信息应该使用什么命令？如何查看内核中已有的字符设备的信息？如何查看正在使用的有哪些中断号？
> 查看驱动模块中打印信息的命令：dmesg
> 查看字符设备信息可以用lsmod 和modprobe，lsmod可以查看模块的依赖关系，modprobe在加载模块时会加载其他依赖的模块。
> 显示当前使用的中断号cat /proc/interrupt
- Linux中引入模块机制有什么好处？
> 可以在使用的时候进行注册，不使用的时候注销。灵活
- copy_to_user()和copy_from_user()主要用于实现什么功能？一般用于file_operations结构的哪些函数里面?
> 由于内核空间和用户空间是不能互相访问的，如果需要访问就必须借助内核函数进行数据读写。copy_to_user():完成内核空间到用户空间的复制，copy_from_user()：是完成用户空间到内核空间的复制。一般用于file_operations结构里的read,write,ioctl等内存数据交换作用的函数。当然，如果ioctl没有用到内存数据复制，那么就不会用到这两个函数。
- 请简述主设备号和次设备号的用途
> 主设备号：主设备号标识设备对应的驱动程序。虽然现代的linux内核允许多个驱动程序共享主设备号，但我们看待的大多数设备仍然按照“一个主设备对应一个驱动程序”的原则组织
> 次设备号：次设备号由内核使用，用于正确确定设备文件所指的设备。依赖于驱动程序的编写方式，我们可以通过次设备号获得一个指向内核设备的直接指针，也可将此设备号当作设备本地数组的索引。
- 请简述中断于DMA的区别。Linux设备驱动程序中，使用哪个函数注册和注销中断处理程序？
> DMA：是一种无须CPU的参与就可以让外设与系统内存之间进行双向数据传输的硬件机制，使用DMA可以使系统CPU从实际的I/O数据传输过程中摆脱出来，从而大大提高系统的吞吐率.
> 中断：是指CPU在执行程序的过程中，出现了某些突发事件时CPU必须暂停执行当前的程序，转去处理突发事件，处理完毕后CPU又返回源程序被中断的位置并继续执行。
> 所以中断和DMA的区别就是DMA不需CPU参与而中断是需要CPU参与的。
- 中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？
> 中断是CPU处于被动状态下来接受设备的信号，而轮询是CPU主动去查询该设备是否有请求。凡事都是两面性，所以，看效率不能简单的说那个效率高。如果是请求设备是一个频繁请求cpu的设备，或者有大量数据请求的网络设备，那么轮询的效率是比中断高。如果是一般设备，并且该设备请求cpu的频率比较底，则用中断效率要高一些。主要是看请求频率。
- 字符型驱动设备怎么创建设备文件
> 手动创建：mknod /dev/led c 250 0    其中dev/led 为设备节点 c 代表字符设备 250代表主设备号 0代表次设备号
- 写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情你是怎么做的？
> 中断处理例程应该尽量短，把能放在后半段(tasklet，等待队列等)的任务尽量放在后半段。
> 中断服务程序中不能有阻塞操作。应为中断期间是完全占用CPU的（即不存在内核调度），中断被阻塞住，其他进程将无法操作；
> 中断服务程序注意返回值，要用操作系统定义的宏做为返回值，而不是自己定义的OK，FAIL之类的。
- 自旋锁和信号量在互斥使用时需要注意哪些?
> 使用自旋锁的进程不能睡眠，使用信号量的进程可以睡眠。
- 原子操作
- insmod 一个驱动模块，会执行模块中的哪个函数？rmmod呢？这两个函数在设计上要注意哪些？遇到过卸载驱动出现异常没？
> insmod调用init函数，rmmod调用exit函数。这两个函数在设计时要注意什么？卸载模块时曾出现卸载失败的情形，原因是存在进程正在使用模块，
- linux内核里面，内存申请有哪几个函数，各自的区别？
> Kmalloc()   __get_free_page()  mempool_create()  
-  IRQ和FIQ有什么区别，在CPU里面是是怎么做的？
> IRQ(Interrupt Request)：指中断模式。
> FIQ(Fast Interrupt Request)：指快速中断模式。
> IRQ可以被FIQ所中断，但FIQ不能被IRQ所中断，在处理FIQ时必须要关闭中断。
> FIQ的优先级比IRQ高。
- 内核函数mmap的实现原理，机制？
- wifi中的SSID、BSSID、ESSID、的区别
> SSID: Service SetIDentifier WLAN的名称
> BSSID：Basic Service SetIDentifier	APMAC地址
> ESSID: Extended Service Set IDentifier
- Linux中主要有哪几种内核锁？
> mutex:互斥量
> semaphore:信号量
> rw_semaphore:读写信号量
> spanlock:自旋锁
> seqlock:顺序锁
> rwlock:读写锁
> RCU：read-copy-update
- Linux中的用户模式和内核模式是什么含意？
> 内核模式的代码可以无限制地访问所有处理器指令集以及全部内存和I/O空间。如果用户模式的进程要享有此特权，它必须通过系统调用向设备驱动程序或其他内核模式的代码发出请求。另外，用户模式的代码允许发生缺页，而内核模式的代码则不允许
- 怎样申请大块内核内存？
> 在Linux内核环境下，申请大块内存的成功率随着系统运行时间的增加而减少，虽然可以通过vmalloc系列调用申请物理不连续但虚拟地址连续的内存
- 用户进程间通信主要哪几种方式？
> 管道、信号、消息队列、共享内存、信号量、套接字
